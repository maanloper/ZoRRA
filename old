change_from_to() {
    ## Input variables
    local input1="$1" # Text for the left side of the '>'
    local input2="$2" # Text for the right side of the '>'

    ## Calculate the maximum width of the left column
    local maxlen=$(echo "${input1}" | awk '{ if (length > maxlen) maxlen = length } END { print maxlen }')

    ## Align the output
    paste <(echo "${input1}") <(echo "${input2}") | awk -v maxlen="${maxlen}" 'BEGIN { FS="\t" } { printf "%-*s > %s\n", maxlen, $1, $2 }'
}

overview_mountpoints() {
    local list="$(zfs list -o name,mounted,mountpoint)"
    if [[ -n "$1" ]]; then
        echo "${list}" | head -n 1
    fi
    echo "${list}" | grep --color=always -E "${1:+($1|/$1)}"
    echo
}

check_mountpoint_in_use() {
    local mountpoint=$(zfs get mountpoint -H -o value "$1")
    if lsof | grep -q "${mountpoint}"; then
        echo -e "\nMountpoint '${mountpoint}' is in use by:"
        lsof | grep --color=always "${mountpoint}"
        echo -e "\nMake sure no processes are using the mountpoint before proceeding\n"
        exit 1
    fi
}

unmount_datasets() {
    for dataset in $1; do
        echo "Unmounting ${dataset}"
        if ! unmount_error=$(zfs unmount -f "${dataset}" 2>&1) && [[ ! "${unmount_error}" =~ "not currently mounted" ]]; then
            echo "Cannot unmount ${dataset}"
            echo "Error: ${unmount_error}"
            echo -e "\nCheck which datasets have been unmounted to prevent partial unmounting:\n"
            overview_mountpoints
            exit 1
        fi
    done
}

mount_datasets() {
    for dataset in $1; do
        echo "Mounting ${dataset}"
        if ! mount_error=$(zfs mount "${dataset}" 2>&1) && [[ ! "${mount_error}" =~ "filesystem already mounted" ]]; then
            echo -e "Cannot mount ${dataset}"
            echo -e "Error: ${mount_error}"
            echo -e "\nOverview of mounted datasets:\n"
            overview_mountpoints
            exit 1
        fi
    done
}





################################################################################################################












	## Create boot entry with efibootmgr
	EFI_install() {
		echo "------------> Installing efibootmgr <------------"
		chroot "${MOUNTPOINT}" /bin/bash -x <<-EOCHROOT
			## Install efibootmgr
			#${APT} install -y efibootmgr
			
			## Create backup boot EFI # TODO: when doing generate ZBM for the second+ time, copy the last as -backup?
			cp /boot/efi/EFI/ZBM/vmlinuz-bootmenu /boot/efi/EFI/ZBM/vmlinuz-bootmenu-BACKUP
			cp /boot/efi/EFI/ZBM/initramfs-bootmenu.img /boot/efi/EFI/ZBM/initramfs-bootmenu-BACKUP.img
			efibootmgr -c -d "$DISK" -p "$BOOT_PART" \
				-L "ZFSBootMenu (Backup)" \
				-l '\EFI\ZBM\vmlinuz-bootmenu-BACKUP' \
				-u "ro initrd=\EFI\ZBM\initramfs-bootmenu-BACKUP.img quiet"
			
			## Create main boot EFI
			efibootmgr -c -d "$DISK" -p "$BOOT_PART" \
				-L "ZFSBootMenu" \
				-l '\EFI\ZBM\vmlinuz-bootmenu' \
				-u "ro initrd=\EFI\ZBM\initramfs-bootmenu.img quiet"
			
			sync
			sleep 1
		EOCHROOT
	}


################################################################################################################

	install_docker(){
		## Setup Docker APT source (see: https://docs.docker.com/engine/install/ubuntu) and install Docker
		chroot "${mountpoint}" /bin/bash -x <<-EOCHROOT
			## Add Docker's official GPG key:
			install -m 0755 -d /etc/apt/keyrings
			curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
			chmod a+r /etc/apt/keyrings/docker.asc

			## Add the repository to Apt sources:
			echo \
				"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
				$(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
			tee /etc/apt/sources.list.d/docker.list > /dev/null
			apt update

			## Install Docker
			apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
		EOCHROOT

		## Change default docker logging driver to systemd
		cat <<-EOF >"${mountpoint}/etc/docker/daemon.json"
			{
			"log-driver": "journald"
			}
		EOF
	}